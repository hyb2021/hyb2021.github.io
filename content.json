[{"title":"","date":"2021-11-30T13:38:33.172Z","path":"2021/11/30/学习/","text":"学习发现自己学习根本不懂原理，只是在应用。别人说这是栈，stack。这就是栈，栈是个什么东西，是内存中一块区域。然后，就什么都不清楚。 惜字如金我告诫自己不说话，可是不说话也掩饰不了自己的卑微。有一半时间在打杂，我想站着把钱挣了。","tags":[]},{"title":"java基础复习","date":"2021-11-26T02:13:22.000Z","path":"2021/11/26/基础/","text":"一、java运行 编译:编译器一次把所有*.java文件转成 *.class字节码文件。 类加载:java虚拟机首先将编译好的字节码文件加载到内存。 解释执行:java虚拟机针对加载到内存中的Java类进行解释运行。 总结:java程序是由虚拟机进行解释运行的，而不是操作系统。 二、数据类型强类型语言要求变量的使用要严格符合规定，所有变量必须先定义后才能使用。 Java数据类型分为两大类 基本类型 ​ byte,short,int,long,float,double,char,boolean 引用类型 浮点数类型是有限、离散、舍入误差的、接近的。不用浮点数比较和计算。123456789float f=0.1f;double d=1.0/10;System.out.println(f==d);//falsefloat d1=2332222445555f;float d2=d1+1;System.out.println(d1);//2.33222255E12System.out.println(d2);//2.33222255E12System.out.println(d1==d2);//true 三、类型转换java是强类型语言，因此在进行有些运算的时候，需要用到类型转换。这里的有些运算指的是java数据类型中基本类型，除boolean类型外。 byte，short，char，int，long，float，double 低————————————————高 运算中，不同类型的数据先转化位同一类型，然后运算。运算中，范围小的会自动转换成范围大的。注意是运算中 double d1=28，此处发生类型转化，28默认是int，有运算符”=”，自动转成double 强制类型转换范围大的转成范围小的 自动类型转换范围小的转成范围大的，但是只有在运算中才会发生。 内存溢出123int i=129;byte b1=(byte)i;System.out.println(b1);//-127 byte类型的范围是[-128,127],给129内存溢出了 123456int money=10_0000_0000;int years=20;int total1=money*years;//-1474836480 内存溢出long total2=money*years;//-1474836480 内存依然溢出，因为计算后的数据类型依然时int，转换成long之前已经出现问题long total3=((long)money)*years;//20000000000，此处money和years都是int类型，无法自动类型转换。System.out.println(total3); 分析:虽然money和years都是int类型，转成long可以自动类型转化。但是money和int都是int，运算无法触发自动类型转换。因此需要类型转换。 四、变量变量是内存中的一块空间。java字节码文件加载进内存并解释执行，代码中如果定义了一个变量，那么内存中就开辟一块空间存储数据。 java是一种强类型语言，每个变量都必须声明其类型。java变量是程序中最基本的存储单元，其要素包括变量名、变量类型、作用域。变量的作用域1.局部变量方法中的变量，作用域在方法内，使用前必须声明和初始化。 2.实例变量方法外类中的变量，使用前不需要初始化，有默认值。(此处的默认值，是由于创建对象时调用空的构造方法初始化)。引用类型默认值是null 对象.变量名 3.类变量1static double salary=2500; 常量1static final double PI=9;//修饰符static不区分顺序 五、方法java方法是语句的集合，他们在一起执行一个功能。方法重载一个类中，方法名相同，参数列表不同(包括参数类型不同、参数个数不同、参数顺序不同)。 递归方法自己调用自己 1234567891011//递归//求5的阶乘public static int jieCheng(int a)&#123; if(a==1)&#123; return a; &#125;else &#123; //return a*(jiecheng(a-1));报错 java: 找不到符号 return a*jieCheng(a-1); &#125;&#125; 此处未解 六、类创建与初始化对象使用new关键字创建对象，分配内容空间，并且调用构造方法给对象初始化。 12345678910public class Person &#123; String name; int age; //方法 public void study()&#123; System.out.println(&quot;学习&quot;); &#125;&#125; 实例变量name和age属于对象，因此定义时不需要初始化，在创建对象时，关键字new构造方法初始化对象。 构造方法 空的无参构造方法 ​ 当没有指定构造方法时，系统会自动添加无参的构造方法。 无参构造方法 有参构造方法 .当我们手动的指定了构造方法时，无论是有参的还是无参的，系统都将不会再添加无参的构造方法 构造方法是不被继承的 构造方法与类同名，没有返回值也没有void alt+ins快速生成构造方法 12345678910111213141516171819202122public class Person &#123; String name; int age; public Person() &#123; &#125; public Person(String name) &#123; this.name = name;//this指的是Person实例，this引用的name是实例变量，&quot;=&quot;右边的name是被赋值后的形参。 &#125; public Person(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; //方法 public void study()&#123; System.out.println(&quot;学习&quot;); &#125;&#125; 123456789public class Application &#123; public static void main(String[] args) &#123; Person hyb=new Person(&quot;张三&quot;);//通过debug，此处调用构造方法Person(String name),age值是0，虽然没有传参初始化。 hyb.study(); int age1=hyb.age; System.out.println(age1); &#125;&#125; 七 方法区、栈、堆代码12345678910111213141516171819202122232425262728//AppMainpublic class AppMain &#123; //运行时，JVM把AppMain的信息都放入方法区 public static void main(String[] args) &#123; //main成员方法本身放入方法区。 Sample test1 = new Sample( &quot; 测试1 &quot; ); //test1是引用，所以放到栈区里，Sample是自定义对象应该放到堆里面 Sample test2 = new Sample( &quot; 测试2 &quot; ); test1.printName(); test2.printName(); &#125; &#125; // Sample.java public class Sample &#123; //运行时，JVM把appmain的信息都放入方法区。 private name; //new Sample实例后，name引用放入栈区里，name对象放入堆里。 public Sample(String name) &#123; this.name = name; &#125; public void printName() &#123;// printName()成员方法本身放入方法区里。 System.out.println(name); &#125; &#125; 运行过程 AppMain.java和Sample.java编译成AppMain.class和Sample.class 系统收到了运行的指令，启动了一个java虚拟机进程。首先把main方法所在类加载进方法区。这一过程称作AppMain类加载。 JVM定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。在栈中，创建一块空间，用于存储main方法中的变量(基本数据类型变量和引用变量)。 执行main方法中第一条指令，Sample test1 = new Sample(“测试1”)。创建一个Sanple对象，jvm去方法区（方法区存放已经加载的类的相关信息，如类、静态变量和常量）找Sample的类信息。这会儿的方法区里还没有Sample类呢（即Sample类的类信息还没有进入方法区中）。jvm立马加载了Sample类， 把Sample类的相关信息存放在了方法区中。 加载完Sample类，jvm在堆中为Sample实例分配内存。这个Sample类的实例持有着指向方法区的Sample类的类型信息的引用（Java中引用就是内存地址）。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址。 在JVM中的一个进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素被称为栈帧，每当线程调用一个方法的时候就会向方法栈中压入一个新栈帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。位于“=”前的test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，test1这个局部变量会被JVM添加到执行main()方法的主线程的Java方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，test1这个局部变量持有指向Sample类的实例的引用（即内存地址）。 接下来，JVM将继续执行后续指令，在堆区里继续创建另一个Sample类的实例，然后依次执行它们的printName()方法。当JVM执行test1.printName()方法时，JVM根据局部变量test1持有的引用，定位到堆中的Sample类的实例，再根据Sample类的实例持有的引用，定位到方法区中Sample类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取printName()成员方法的字节码，接着执行printName()成员方法包含的指令。 图","tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"帆软","date":"2021-11-26T02:13:22.000Z","path":"2021/11/26/帆软/","text":"1.点击查询前显示所有内容点击参数栏，参数栏的属性取消勾选点击查询前不显示报表内容。 2.给报表内容插序号","tags":[{"name":"帆软","slug":"帆软","permalink":"http://example.com/tags/%E5%B8%86%E8%BD%AF/"}]},{"title":"生日计时","date":"2021-11-16T13:03:06.000Z","path":"2021/11/16/生日计时/","text":"生日计时请点击 :计时","tags":[]},{"title":"飘风不终朝，骤雨不终日","date":"2021-10-26T02:13:22.000Z","path":"2021/10/26/飘风不终朝，骤雨不终日/","text":"太用力的人跑不远。道德经里有这样一句话: 飘风不终朝，骤雨不终日。狂风不会刮一个早晨，暴雨不会下一整天。 短暂而快速的奔跑，只会让你迅速消耗完你的精神能量，然后让你变得萎靡不振。 短时间的高投入，意味着短时间有一个高回报。无法容忍投入后没有回报，因此结果只会是立马放弃。 真正的坚持，来源于一种温柔而又坚定的力量，而不是时时刻刻去找刺激。 人越用力，越是容易让自己的神经过载。大量地增加负荷去求得一个正反馈，当负反馈来临的时候，往往不能接受而变得抑郁焦虑。 过度努力的人只是在不断地瞎折腾自己，而真正坚持下来的人往往显得非常轻松","tags":[{"name":"知乎","slug":"知乎","permalink":"http://example.com/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"道德经","slug":"道德经","permalink":"http://example.com/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"}]},{"title":"安装环境","date":"2021-10-12T02:38:29.000Z","path":"2021/10/12/安装环境/","text":"Node.jsNode.js是运行在服务端的JavaScript。 NPM Npm是Node.js的包管理工具。 我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 YarnYarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码，或者分享自己的代码。 Yarn 做这些快捷、安全、可靠，所以你不用担心什么。","tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Markdown的坑","date":"2021-10-12T02:38:29.000Z","path":"2021/10/12/Markdown的坑/","text":"1.```使用```开头之前必须要有一行空行使用```结束时切记不要在结束标签后加空格，否则该标签未关闭。 2. `一句话中使用 ` 标签包着一个字或一个词。 3.换行两种方案1.两个空格然后回车2.使用&lt;br&gt; 4.字体大小、颜色、类型、加粗、倾斜&lt;font size=5&gt;Hello&lt;font color=red&gt;Hello&lt;font face=&quot;微软雅黑&quot;&gt;Hello*加粗***倾斜** 5. 引用 单行&gt; Dorothy followed her through many of the beautiful rooms in her castle. Dorothy followed her through many of the beautiful rooms in her castle. 多行 1234&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.&gt; Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 6.列表 有序1. 无序-","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"Hexo搭建遇到的问题","date":"2021-10-09T07:24:38.000Z","path":"2021/10/09/Hexo搭建遇到的问题/","text":"2021年10月9日更新:Hexo博客在部署时遇到很多问题，记录下遇到的问题。 1.把本地内容推到github遇到报错”fatal: unable to auto-detect email address”在blog目录下执行 123hexo clean //清除缓存hexo g //生成静态文件hexo d //部署到GitHub 出现报错误fatal: unable to auto-detect email address原因是未配置GitHub用户名何邮箱。 12git config --global user.email &quot;git邮箱&quot;git config --global user.name &quot;git用户名&quot; 2.文章分类和标签1234567title: Hello World date: 2013/7/13 20:46:25 categories: - 分类名 tags: - 标签1 - 标签2 3.新建命令1hexo new 标题","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}]