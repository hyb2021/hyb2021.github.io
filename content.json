[{"title":"天信平台","date":"2021-12-08T15:13:22.000Z","path":"2021/12/08/天信低代码开发平台/","text":"天信低代码开发平台1、如何删除创建的模块前端: hussar-front/src/pages/index/api/tenancy_000/下的模块 hussar-front/src/pages/index/views/tenancy_000/下的模块 后端: hussar-plugin/hussar-tenanc_000下的模块 hussar-plugin/pom.xml中 中的模块删除 2、流程模板位置hussar-web/src/main/resource/common_moudule/settings/ 注意:模板的审批详情页面，选中表单，交互/组件列。如果直接使用，那么新流程的审批详情页面会出现模板的组件列和自建流程的组件列。建议把模板的组件列删除。 3、部署注意 租户的编码统一 tenancy_000 租户安全员/租户级应用管理/租户级应用维护，应用名、应用英文名必须与模块名字、模块英文名一致。 4、新建流程数据模型审批列表审批详情工作流修改1、绘制流程环节。2、更换数据模型、待办配置下的业务详情(配置一个字段在个人待办的标题中显示)流程的属性/数据模型 流程的属性/待办配置，业务表变量拖到业务详情。 3、给流程环节配置审批角色(开始环节不需要)选中环节，右键/参与者。 4、表单地址和表单详情配置(开始环节需要)选中环节，属性/表单地址配置 ，属性/表单详情配置。配置web为流程的审批详情页面。 5、表单权限配置(开始环节也需要)表单地址配置:配置待办界面 表单详情配置:配置已办界面 选址环节，右键权限配置,进去表单权限配置。请先勾选“全选”，然后点击“全部显示”，之后按照各个流程环节的组件权限进行设置隐藏、禁用等。","tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"天信","slug":"天信","permalink":"http://example.com/tags/%E5%A4%A9%E4%BF%A1/"}]},{"title":"java基础复习2","date":"2021-12-02T02:13:22.000Z","path":"2021/12/02/基础2/","text":"一、修饰符static1、静态代码块1234567891011121314public class AppTestOne &#123; public static void main(String[] args) &#123; int x=10; System.out.println(x); &#125; static &#123; int y=20; System.out.println(y); &#125;&#125;//执行结果 ：20// 10 静态代码块随着类的加载而加载，且只执行一次，优先main方法执行。 什么时候会使用静态代码块？ 2、静态成员变量1234567891011121314151617181920212223package javastudy;public class StaticDemo &#123; public static void main(String[] args) &#123; Child c1=new Child(); c1.name=&quot;zhangsan&quot;; c1.speak(); Child c2=new Child(); c2.name=&quot;lisi&quot;; c2.speak(); &#125;&#125;class Child&#123; String name; static String country=&quot;CN&quot;; //将数据值相同且共用的用static修饰，成为类变量 void speak()&#123; System.out.println(&quot;My name is &quot;+name+&quot;,my country is &quot;+country); &#125;&#125; static修饰符修饰的成员变量随着类的加载而加载。 如上，创建Child实例，Child类加载进内存的方法区，此时static String country=”CN”;就在方法区开辟好了空间。被Child类的所有实体共享。而String name则是随着实例的创建存在于堆内存中。 static成员变量的特点 被所有对象所共享。当被该类的对象修改时，对其它对象也一同发生变化。可以直接被类名所调用。 静态成员变量随着类的消失而消失；成员变量随着对象的消失而消失。 3、静态成员方法static修饰的成员方法，属于类，可以直接被类名调用，不需要再消耗资源反复创建对象。如果不是static修饰的成员函数，在使用完之后就会立即被JVM回收。 注意：静态方法只能访问静态数据和静态方法 原因是：静态成员变量会随着类的加载而分配内存空间。非静态变量只会在创建对象时分配堆内存的。 问题？jvm怎么处理静态方法和非静态方法，是不是只有调用该方法时，才会在栈中分配内存空间给方法中的局部变量？ 二、 Java方法参数传递是值传递还是引用传递java中方法参数传递方式是按值传递。 如果参数是基本类型，传递的是基本类型的字面量值的拷贝。 如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。**(java传的是地址值，地址值拷贝不会修改地址值)** 值传递是指: 调用函数时将实际参数复制一份传递到函数中，这样函数中如果对参数进行修改，将不会影响到实际参数。 三、Java方法Method及其内存分配方法只定义不调用，是不会执行的，并且jvm也不会给方法分配”运行所属”的内存空间。只有在调用该方法的时候，才会动态的给这个方法分配内存空间。 方法代码片段在哪？方法代码片段属于.class字节码文件的一部分，字节码文件在类加载的时候，将其放到了方法区中。 方法执行的时候执行过程的内存在哪里分配?代码片段虽然在方法区内存当中只有一份，但是可以被重复调用。每一次调用这个方法的时候，需要给该方法分配独立的活动场所。，在栈内存中分配。 方法在被调用的瞬间，会给该方法分配内存空间，会在栈中发生压栈动作，方法执行结束后，给该方法分配的内存空间全部释放，此时发生弹栈动作。 局部变量在方法体中声明，局部变量运行阶段内存在栈中分配。 方法区内存一个，堆内存一个，栈内存一个线程一个 四、Java类的声明周期java的声明周期指的是一个class文件从加载到卸载的全过程。 首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色： 方法区：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量 以及方法代码的内存区域，叫做方法区。常量池：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。堆区：用于存放类的对象实例。栈区：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。 除了以上四个内存区域之外，jvm中的运行时内存区域还包括本地方法栈和程序计数器，这两个区域与java类的生命周期关系不是很大，在这里就不说了，感兴趣的朋友可以自己百度一下。 加载当一个类需要被使用，jvm把类的信息加载到方法区中。 连接 验证:当一个类被加载后，必须要验证下这个类是否合法。 准备:为类的静态变量分配内存并设为jvm默认的初始值，对于非静态变量，则不会为他们分配内存。 注意:这时候，静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。jvm默认的初值是这样的：基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0。引用类型的默认值为null。常量的默认值为我们程序中设定的值，比如我们在程序中定义final static int a = 100，则准备阶段中a的初值就是100。 ​ 3. 解析:目前没精力学习 初始化即类的初始化 当创建对象、调用类的静态方法、读取或设置类的静态变量 反射 初始化子类的时候，触发初始化父类 作为程序入口直接运行，也就是直接调用main方法 使用目前没精力学习 卸载jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。 (27条消息) 详解java类的生命周期_三级小野怪的专栏-CSDN博客_类的生命周期 四、异常捕获异常可以让程序继续运行下去，不会停止。","tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"java基础复习1","date":"2021-11-26T02:13:22.000Z","path":"2021/11/26/基础1/","text":"一、java运行 编译:编译器一次把所有*.java文件转成 *.class字节码文件。 类加载:java虚拟机首先将编译好的字节码文件加载到内存。 解释执行:java虚拟机针对加载到内存中的Java类进行解释运行。 总结:java程序是由虚拟机进行解释运行的，而不是操作系统。 二、数据类型强类型语言要求变量的使用要严格符合规定，所有变量必须先定义后才能使用。 Java数据类型分为两大类 基本类型 ​ byte,short,int,long,float,double,char,boolean 引用类型 浮点数类型是有限、离散、舍入误差的、接近的。不用浮点数比较和计算。123456789float f=0.1f;double d=1.0/10;System.out.println(f==d);//falsefloat d1=2332222445555f;float d2=d1+1;System.out.println(d1);//2.33222255E12System.out.println(d2);//2.33222255E12System.out.println(d1==d2);//true 三、类型转换java是强类型语言，因此在进行有些运算的时候，需要用到类型转换。这里的有些运算指的是java数据类型中基本类型，除boolean类型外。 byte，short，char，int，long，float，double 低————————————————高 运算中，不同类型的数据先转化位同一类型，然后运算。运算中，范围小的会自动转换成范围大的。注意是运算中 double d1=28，此处发生类型转化，28默认是int，有运算符”=”，自动转成double 强制类型转换范围大的转成范围小的 自动类型转换范围小的转成范围大的，但是只有在运算中才会发生。 内存溢出123int i=129;byte b1=(byte)i;System.out.println(b1);//-127 byte类型的范围是[-128,127],给129内存溢出了 123456int money=10_0000_0000;int years=20;int total1=money*years;//-1474836480 内存溢出long total2=money*years;//-1474836480 内存依然溢出，因为计算后的数据类型依然时int，转换成long之前已经出现问题long total3=((long)money)*years;//20000000000，此处money和years都是int类型，无法自动类型转换。System.out.println(total3); 分析:虽然money和years都是int类型，转成long可以自动类型转化。但是money和int都是int，运算无法触发自动类型转换。因此需要类型转换。 四、变量变量是内存中的一块空间。java字节码文件加载进内存并解释执行，代码中如果定义了一个变量，那么内存中就开辟一块空间存储数据。 java是一种强类型语言，每个变量都必须声明其类型。java变量是程序中最基本的存储单元，其要素包括变量名、变量类型、作用域。变量的作用域1.局部变量方法中的变量，作用域在方法内，使用前必须声明和初始化。 2.实例变量方法外类中的变量，使用前不需要初始化，有默认值。(此处的默认值，是由于创建对象时调用空的构造方法初始化)。引用类型默认值是null 对象.变量名 3.类变量1static double salary=2500; 常量1static final double PI=9;//修饰符static不区分顺序 五、方法java方法是语句的集合，他们在一起执行一个功能。方法重载一个类中，方法名相同，参数列表不同(包括参数类型不同、参数个数不同、参数顺序不同)。 递归方法自己调用自己 1234567891011//递归//求5的阶乘public static int jieCheng(int a)&#123; if(a==1)&#123; return a; &#125;else &#123; //return a*(jiecheng(a-1));报错 java: 找不到符号 return a*jieCheng(a-1); &#125;&#125; 此处未解 六、类创建与初始化对象使用new关键字创建对象，分配内容空间，并且调用构造方法给对象初始化。 12345678910public class Person &#123; String name; int age; //方法 public void study()&#123; System.out.println(&quot;学习&quot;); &#125;&#125; 实例变量name和age属于对象，因此定义时不需要初始化，在创建对象时，关键字new构造方法初始化对象。 构造方法 空的无参构造方法 ​ 当没有指定构造方法时，系统会自动添加无参的构造方法。 无参构造方法 有参构造方法 .当我们手动的指定了构造方法时，无论是有参的还是无参的，系统都将不会再添加无参的构造方法 构造方法是不被继承的 构造方法与类同名，没有返回值也没有void alt+ins快速生成构造方法 12345678910111213141516171819202122public class Person &#123; String name; int age; public Person() &#123; &#125; public Person(String name) &#123; this.name = name;//this指的是Person实例，this引用的name是实例变量，&quot;=&quot;右边的name是被赋值后的形参。 &#125; public Person(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; //方法 public void study()&#123; System.out.println(&quot;学习&quot;); &#125;&#125; 123456789public class Application &#123; public static void main(String[] args) &#123; Person hyb=new Person(&quot;张三&quot;);//通过debug，此处调用构造方法Person(String name),age值是0，虽然没有传参初始化。 hyb.study(); int age1=hyb.age; System.out.println(age1); &#125;&#125; 七 方法区、栈、堆代码12345678910111213141516171819202122232425262728//AppMainpublic class AppMain &#123; //运行时，JVM把AppMain的信息都放入方法区 public static void main(String[] args) &#123; //main成员方法本身放入方法区。 Sample test1 = new Sample( &quot; 测试1 &quot; ); //test1是引用，所以放到栈区里，Sample是自定义对象应该放到堆里面 Sample test2 = new Sample( &quot; 测试2 &quot; ); test1.printName(); test2.printName(); &#125; &#125; // Sample.java public class Sample &#123; //运行时，JVM把appmain的信息都放入方法区。 private name; //new Sample实例后，name引用放入栈区里，name对象放入堆里。 public Sample(String name) &#123; this.name = name; &#125; public void printName() &#123;// printName()成员方法本身放入方法区里。 System.out.println(name); &#125; &#125; 运行过程 AppMain.java和Sample.java编译成AppMain.class和Sample.class 系统收到了运行的指令，启动了一个java虚拟机进程。首先把main方法所在类加载进方法区。这一过程称作AppMain类加载。 JVM定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。在栈中，创建一块空间，用于存储main方法中的变量(基本数据类型变量和引用变量)。 执行main方法中第一条指令，Sample test1 = new Sample(“测试1”)。创建一个Sanple对象，jvm去方法区（方法区存放已经加载的类的相关信息，如类、静态变量和常量）找Sample的类信息。这会儿的方法区里还没有Sample类呢（即Sample类的类信息还没有进入方法区中）。jvm立马加载了Sample类， 把Sample类的相关信息存放在了方法区中。 加载完Sample类，jvm在堆中为Sample实例分配内存。这个Sample类的实例持有着指向方法区的Sample类的类型信息的引用（Java中引用就是内存地址）。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址。总结:堆中的Sample实例指向方法区中的Sample类的类信息内存地址。&gt; 在JVM中的一个进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素被称为栈帧，每当线程调用一个方法的时候就会向方法栈中压入一个新栈帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。位于“=”前的test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，test1这个局部变量会被JVM添加到执行main()方法的主线程的Java方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，test1这个局部变量持有指向Sample类的实例的引用（即内存地址）。 接下来，JVM将继续执行后续指令，在堆区里继续创建另一个Sample类的实例，然后依次执行它们的printName()方法。当JVM执行test1.printName()方法时，JVM根据局部变量test1持有的引用，定位到堆中的Sample类的实例，再根据Sample类的实例持有的引用，定位到方法区中Sample类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取printName()成员方法的字节码，接着执行printName()成员方法包含的指令。&gt; 图 八、栈中的变量是临时的基本数据类型、局部变量都是存放在栈内存中的，用完就消失。new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。 1234567891011121314public class AppMain &#123; public static void main(String[] args) &#123; int x=1; show(); &#125; static void show()&#123; int x=2; &#125;&#125; 执行顺序第1步——main()函数是程序入口，JVM先执行，在栈内存中开辟一个空间，存放int类型变量x，同时附值1。第2步——JVM执行show()函数，在栈内存中又开辟一个新的空间，存放int类型变量x，同时附值2。 此时main空间与show空间并存，同时运行，互不影响。第3步——show()执行完毕，变量x立即释放，空间消失。但是main()函数空间仍存在，main中的变量x仍然存在，不受影响。","tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"帆软","date":"2021-11-26T02:13:22.000Z","path":"2021/11/26/帆软/","text":"1.点击查询前显示所有内容点击参数栏，参数栏的属性取消勾选点击查询前不显示报表内容。 2.给报表内容插序号","tags":[{"name":"帆软","slug":"帆软","permalink":"http://example.com/tags/%E5%B8%86%E8%BD%AF/"}]},{"title":"生日计时","date":"2021-11-16T13:03:06.000Z","path":"2021/11/16/生日计时/","text":"生日计时请点击 :计时","tags":[]},{"title":"飘风不终朝，骤雨不终日","date":"2021-10-26T02:13:22.000Z","path":"2021/10/26/飘风不终朝，骤雨不终日/","text":"太用力的人跑不远。道德经里有这样一句话: 飘风不终朝，骤雨不终日。狂风不会刮一个早晨，暴雨不会下一整天。 短暂而快速的奔跑，只会让你迅速消耗完你的精神能量，然后让你变得萎靡不振。 短时间的高投入，意味着短时间有一个高回报。无法容忍投入后没有回报，因此结果只会是立马放弃。 真正的坚持，来源于一种温柔而又坚定的力量，而不是时时刻刻去找刺激。 人越用力，越是容易让自己的神经过载。大量地增加负荷去求得一个正反馈，当负反馈来临的时候，往往不能接受而变得抑郁焦虑。 过度努力的人只是在不断地瞎折腾自己，而真正坚持下来的人往往显得非常轻松","tags":[{"name":"知乎","slug":"知乎","permalink":"http://example.com/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"道德经","slug":"道德经","permalink":"http://example.com/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"}]},{"title":"Markdown的坑","date":"2021-10-12T02:38:29.000Z","path":"2021/10/12/Markdown的坑/","text":"1.```使用```开头之前必须要有一行空行使用```结束时切记不要在结束标签后加空格，否则该标签未关闭。 2. `一句话中使用 ` 标签包着一个字或一个词。 3.换行两种方案1.两个空格然后回车2.使用&lt;br&gt; 4.字体大小、颜色、类型、加粗、倾斜&lt;font size=5&gt;Hello&lt;font color=red&gt;Hello&lt;font face=&quot;微软雅黑&quot;&gt;Hello*加粗***倾斜** 5. 引用 单行&gt; Dorothy followed her through many of the beautiful rooms in her castle. Dorothy followed her through many of the beautiful rooms in her castle. 多行 1234&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.&gt; Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 6.列表 有序1. 无序- 7.颜色&lt;font color=red&gt;我是红色&lt;/font&gt;","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"安装环境","date":"2021-10-12T02:38:29.000Z","path":"2021/10/12/安装环境/","text":"Node.jsNode.js是运行在服务端的JavaScript。 NPM Npm是Node.js的包管理工具。 我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 YarnYarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码，或者分享自己的代码。 Yarn 做这些快捷、安全、可靠，所以你不用担心什么。","tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Hexo搭建遇到的问题","date":"2021-10-09T07:24:38.000Z","path":"2021/10/09/Hexo搭建遇到的问题/","text":"2021年10月9日更新:Hexo博客在部署时遇到很多问题，记录下遇到的问题。 1.把本地内容推到github遇到报错”fatal: unable to auto-detect email address”在blog目录下执行 123hexo clean //清除缓存hexo g //生成静态文件hexo d //部署到GitHub 出现报错误fatal: unable to auto-detect email address原因是未配置GitHub用户名何邮箱。 12git config --global user.email &quot;git邮箱&quot;git config --global user.name &quot;git用户名&quot; 2.文章分类和标签1234567title: Hello World date: 2013/7/13 20:46:25 categories: - 分类名 tags: - 标签1 - 标签2 3.新建命令1hexo new 标题","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}]